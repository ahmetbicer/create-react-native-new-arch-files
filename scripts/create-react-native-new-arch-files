#!/usr/bin/env node

const fs = require("fs");
const replace = require("replace-in-file");

const help = process.argv.includes("-h") || process.argv.includes("--help");

if (help) {
	console.log("Create React Native New Architecture Files ðŸŽ‰\n");
	console.log("This script creates necessary files for new architecture");
	console.log("You still have to apply additional diff");
	console.log("Usage: npx create-react-native-new-architecture-files\n");
	console.log("Command options:");
	console.log("-h, --help         Print usage info.");
	process.exit(0);
}

const readline = require("readline");

const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout,
});

let packageName;

// check if their git working tree is dirty
if (isGitDirty()) {
	console.error("Your git working tree is dirty.");
	console.error("Please commit or stash your changes and re-run the script.");
	process.exit(1);
} else {
	startSetup();
}

function startSetup() {
	const appJSON = JSON.parse(fs.readFileSync(process.cwd() + "/app.json"));
	const packageJSON = JSON.parse(
		fs.readFileSync(process.cwd() + "/package.json")
	);

	const defaultAppName =
		appJSON?.name || appJSON?.expo?.name || packageJSON.name || "MyApp";

	const defaultPackageName = `com.${defaultAppName.toLowerCase()}`;

	packageName = defaultPackageName;

	rl.question(
		`App package name? [${defaultPackageName}] `,
		function (userPackageName) {
			packageName = userPackageName || defaultPackageName;

			rl.close();
		}
	);
	rl.on("close", createFiles);
}

function createFiles() {
	const files = fs.readdirSync(".");
	console.log(files);
	// fs.copyFileSync("../files", process.cwd());

	// const options = {
	// 	files: ["files/**"],
	// 	from: /com.rndiffapp/g,
	// 	to: packageName,
	// };

	// const results = replace.sync(options);
}

function isGitDirty() {
	const output = require("child_process").spawnSync("git", [
		"status",
		"--porcelain",
	]);
	if (output.status === 0) {
		return output.stdout.toString().trim().length > 0;
	}
}
